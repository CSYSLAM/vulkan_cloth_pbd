#version 450

struct Particle {
    vec4 pos;
    vec4 vel;
    vec4 uv;
    vec4 normal;
};

layout(std430, binding = 0) buffer ParticleIn {
    Particle particleIn[ ];
};

layout(std430, binding = 1) buffer ParticleOut {
    Particle particleOut[ ];
};

layout (local_size_x = 10, local_size_y = 10) in;

layout (binding = 2) uniform UBO 
{
    float deltaT;
    float particleMass;
    float springStiffness;
    float damping;
    float restDistH;
    float restDistV;
    float restDistD;
    float sphereRadius;
    vec4 spherePos;
    vec4 gravity;
    ivec2 particleCount;
} params;

layout (push_constant) uniform PushConsts {
    uint calculateNormals;
} pushConsts;

shared Particle sharedParticles[12][12];

vec3 springForce(vec3 p0, vec3 p1, float restDist) 
{
    vec3 dist = p0 - p1;
    return normalize(dist) * params.springStiffness * (length(dist) - restDist);
}

void main() 
{
    uvec3 id = gl_GlobalInvocationID;
    uvec3 localId = gl_LocalInvocationID;
    uvec3 groupId = gl_WorkGroupID;

    uint index = id.y * params.particleCount.x + id.x;
    if (index >= params.particleCount.x * params.particleCount.y) 
        return;

    // Load particles into shared memory
    sharedParticles[localId.y + 1][localId.x + 1] = particleIn[index];

    // Load boundary particles
    if (localId.x == 0 && id.x > 0)
        sharedParticles[localId.y + 1][0] = particleIn[index - 1];
    if (localId.x == 9 && id.x < params.particleCount.x - 1)
        sharedParticles[localId.y + 1][11] = particleIn[index + 1];
    if (localId.y == 0 && id.y > 0)
        sharedParticles[0][localId.x + 1] = particleIn[index - params.particleCount.x];
    if (localId.y == 9 && id.y < params.particleCount.y - 1)
        sharedParticles[11][localId.x + 1] = particleIn[index + params.particleCount.x];

    // Load corner particles
    if (localId.x == 0 && localId.y == 0 && id.x > 0 && id.y > 0)
        sharedParticles[0][0] = particleIn[index - params.particleCount.x - 1];
    if (localId.x == 9 && localId.y == 0 && id.x < params.particleCount.x - 1 && id.y > 0)
        sharedParticles[0][11] = particleIn[index - params.particleCount.x + 1];
    if (localId.x == 0 && localId.y == 9 && id.x > 0 && id.y < params.particleCount.y - 1)
        sharedParticles[11][0] = particleIn[index + params.particleCount.x - 1];
    if (localId.x == 9 && localId.y == 9 && id.x < params.particleCount.x - 1 && id.y < params.particleCount.y - 1)
        sharedParticles[11][11] = particleIn[index + params.particleCount.x + 1];

    // Synchronize to make sure all particles are loaded
    barrier();

    // Initial force from gravity
    vec3 force = params.gravity.xyz * params.particleMass;

    vec3 pos = sharedParticles[localId.y + 1][localId.x + 1].pos.xyz;
    vec3 vel = sharedParticles[localId.y + 1][localId.x + 1].vel.xyz;

    // Spring forces from neighboring particles
    if (id.x > 0)
        force += springForce(sharedParticles[localId.y + 1][localId.x].pos.xyz, pos, params.restDistH);
    if (id.x < params.particleCount.x - 1)
        force += springForce(sharedParticles[localId.y + 1][localId.x + 2].pos.xyz, pos, params.restDistH);
    if (id.y < params.particleCount.y - 1)
        force += springForce(sharedParticles[localId.y + 2][localId.x + 1].pos.xyz, pos, params.restDistV);
    if (id.y > 0)
        force += springForce(sharedParticles[localId.y][localId.x + 1].pos.xyz, pos, params.restDistV);
    if (id.x > 0 && id.y < params.particleCount.y - 1)
        force += springForce(sharedParticles[localId.y + 2][localId.x].pos.xyz, pos, params.restDistD);
    if (id.x > 0 && id.y > 0)
        force += springForce(sharedParticles[localId.y][localId.x].pos.xyz, pos, params.restDistD);
    if (id.x < params.particleCount.x - 1 && id.y < params.particleCount.y - 1)
        force += springForce(sharedParticles[localId.y + 2][localId.x + 2].pos.xyz, pos, params.restDistD);
    if (id.x < params.particleCount.x - 1 && id.y > 0)
        force += springForce(sharedParticles[localId.y][localId.x + 2].pos.xyz, pos, params.restDistD);

    force += (-params.damping * vel);

    // Integrate
    vec3 f = force * (1.0 / params.particleMass);
    particleOut[index].pos = vec4(pos + vel * params.deltaT + 0.5 * f * params.deltaT * params.deltaT, 1.0);
    particleOut[index].vel = vec4(vel + f * params.deltaT, 0.0);

    // Sphere collision
    vec3 sphereDist = particleOut[index].pos.xyz - params.spherePos.xyz;
    if (length(sphereDist) < params.sphereRadius + 0.01) {
        particleOut[index].pos.xyz = params.spherePos.xyz + normalize(sphereDist) * (params.sphereRadius + 0.01);        
        particleOut[index].vel = vec4(0.0);
    }

    // Normals
    if (pushConsts.calculateNormals == 1) {
        vec3 normal = vec3(0.0);
        vec3 a, b, c;
        if (id.y > 0) {
            if (id.x > 0) {
                a = sharedParticles[localId.y + 1][localId.x].pos.xyz - pos;
                b = sharedParticles[localId.y][localId.x].pos.xyz - pos;
                c = sharedParticles[localId.y][localId.x + 1].pos.xyz - pos;
                normal += cross(a,b) + cross(b,c);
            }
            if (id.x < params.particleCount.x - 1) {
                a = sharedParticles[localId.y][localId.x + 1].pos.xyz - pos;
                b = sharedParticles[localId.y][localId.x + 2].pos.xyz - pos;
                c = sharedParticles[localId.y + 1][localId.x + 2].pos.xyz - pos;
                normal += cross(a,b) + cross(b,c);
            }
        }
        if (id.y < params.particleCount.y - 1) {
            if (id.x > 0) {
                a = sharedParticles[localId.y + 2][localId.x + 1].pos.xyz - pos;
                b = sharedParticles[localId.y + 2][localId.x].pos.xyz - pos;
                c = sharedParticles[localId.y + 1][localId.x].pos.xyz - pos;
                normal += cross(a,b) + cross(b,c);
            }
            if (id.x < params.particleCount.x - 1) {
                a = sharedParticles[localId.y + 1][localId.x + 2].pos.xyz - pos;
                b = sharedParticles[localId.y + 2][localId.x + 2].pos.xyz - pos;
                c = sharedParticles[localId.y + 2][localId.x + 1].pos.xyz - pos;
                normal += cross(a,b) + cross(b,c);
            }
        }
        particleOut[index].normal = vec4(normalize(normal), 0.0f);
    }
}
